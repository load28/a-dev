use anyhow::Result;
use std::collections::HashMap;
use std::sync::Arc;

use autodev_core::{AutoDevEngine, Task, TaskStatus};
use autodev_github::{GitHubClient, Repository};
use autodev_ai::AIAgent;
use autodev_db::Database;

pub struct TaskExecutor {
    engine: Arc<AutoDevEngine>,
    github_client: Arc<GitHubClient>,
    ai_agent: Arc<dyn AIAgent>,
    db: Option<Arc<Database>>,
}

impl TaskExecutor {
    pub fn new(
        engine: Arc<AutoDevEngine>,
        github_client: Arc<GitHubClient>,
        ai_agent: Arc<dyn AIAgent>,
        db: Option<Arc<Database>>,
    ) -> Self {
        Self {
            engine,
            github_client,
            ai_agent,
            db,
        }
    }

    pub async fn execute_task(&self, task: &Task) -> Result<()> {
        tracing::info!("Executing task: {} ({})", task.title, task.id);

        // Update task status to InProgress
        self.engine
            .update_task_status(&task.id, TaskStatus::InProgress, None)
            .await?;

        // Log start
        if let Some(ref db) = self.db {
            db.add_execution_log(&task.id, "STARTED", "Task execution started").await?;
        }

        let start_time = std::time::Instant::now();

        // Get repository information
        let (owner, name) = self.get_repository_info(&task.id).await?;
        let repository = Repository::new(owner, name);

        // Execute task with AI agent
        let result = self.ai_agent
            .execute_task(task, &format!("/workspace/{}", repository.full_name()))
            .await?;

        if !result.success {
            anyhow::bail!("AI agent execution failed");
        }

        tracing::info!("AI agent completed for task: {}", task.id);
        tracing::debug!("Files changed: {:?}", result.files_changed);

        // Create branch if it doesn't exist
        self.github_client
            .create_branch(&repository, &result.pr_branch, &repository.branch)
            .await
            .ok(); // Ignore if branch already exists

        // Trigger GitHub Actions workflow
        let mut workflow_inputs = HashMap::new();
        workflow_inputs.insert("task_id".to_string(), task.id.clone());
        workflow_inputs.insert("branch".to_string(), result.pr_branch.clone());
        workflow_inputs.insert("commit_message".to_string(), result.commit_message.clone());
        workflow_inputs.insert("prompt".to_string(), task.prompt.clone());

        let workflow_run_id = self.github_client
            .trigger_workflow(&repository, "autodev.yml", workflow_inputs)
            .await?;

        tracing::info!("Triggered workflow: {} for task: {}", workflow_run_id, task.id);

        // Wait for workflow completion (simplified - in production, poll status)
        tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;

        // Check workflow status
        let status = self.github_client
            .get_workflow_run_status(&repository, workflow_run_id)
            .await?;

        if status.status == "completed" && status.conclusion == Some("success".to_string()) {
            // Create pull request
            let pr = self.github_client
                .create_pull_request(
                    &repository,
                    format!("[AutoDev] {}", task.title),
                    format!(
                        "## AutoDev Task\n\n\
                        **Task ID:** {}\n\
                        **Description:** {}\n\n\
                        ### Changes\n\
                        {}\n\n\
                        ---\n\
                        *Generated by AutoDev*",
                        task.id,
                        task.description,
                        result.output.unwrap_or_else(|| "Automated changes".to_string())
                    ),
                    result.pr_branch,
                    repository.branch.clone(),
                    false,  // draft = false (single task PRs don't need review)
                )
                .await?;

            tracing::info!("Created PR #{} for task: {}", pr.number, task.id);

            // Update task status to Completed
            self.engine
                .update_task_status(&task.id, TaskStatus::Completed, None)
                .await?;

            // Save metrics
            let elapsed = start_time.elapsed();
            if let Some(ref db) = self.db {
                db.save_metrics(
                    &task.id,
                    elapsed.as_millis() as i64,
                    result.files_changed.len() as i32,
                    100, // Placeholder
                    20,  // Placeholder
                    500, // Placeholder
                ).await?;

                db.add_execution_log(
                    &task.id,
                    "COMPLETED",
                    &format!("Task completed successfully. PR: #{}", pr.number),
                ).await?;
            }
        } else {
            // Workflow failed
            let error_msg = format!("Workflow failed with status: {:?}", status);

            self.engine
                .update_task_status(&task.id, TaskStatus::Failed, Some(error_msg.clone()))
                .await?;

            if let Some(ref db) = self.db {
                db.add_execution_log(&task.id, "FAILED", &error_msg).await?;
            }

            anyhow::bail!(error_msg);
        }

        Ok(())
    }

    async fn get_repository_info(&self, task_id: &str) -> Result<(String, String)> {
        // Try to get from database
        if let Some(ref db) = self.db {
            if let Some(record) = db.get_task(task_id).await? {
                return Ok((record.repository_owner, record.repository_name));
            }
        }

        // Default fallback
        Ok(("myorg".to_string(), "myproject".to_string()))
    }

    // Ìñ•ÌõÑ PR Î¶¨Î∑∞ ÏûêÎèô Ï≤òÎ¶¨ Í∏∞Îä•ÏóêÏÑú ÏÇ¨Ïö© ÏòàÏ†ï
    #[allow(dead_code)]
    pub async fn handle_pr_review(
        &self,
        task_id: &str,
        pr_number: u32,
        review_comments: Vec<String>,
    ) -> Result<()> {
        tracing::info!("Handling PR review for task: {}", task_id);

        let (owner, name) = self.get_repository_info(task_id).await?;
        let repository = Repository::new(owner, name);

        // Get PR diff
        let _pr = self.github_client.get_pull_request(&repository, pr_number).await?;
        let pr_diff = ""; // Would fetch actual diff from GitHub

        // Use AI to address review comments
        let result = self.ai_agent
            .review_code_changes(pr_diff, &review_comments)
            .await?;

        if result.success {
            tracing::info!("Applied fixes for review comments on PR #{}", pr_number);

            // Comment on PR
            let comment = format!(
                "‚úÖ Applied fixes based on review comments:\n\n{}\n\n**Changes made:**\n{}",
                result.comments.join("\n"),
                result.changes_made.iter()
                    .map(|c| format!("- {}", c))
                    .collect::<Vec<_>>()
                    .join("\n")
            );

            self.github_client
                .create_pr_comment(&repository, pr_number, &comment)
                .await?;

            // Log to database
            if let Some(ref db) = self.db {
                db.add_execution_log(
                    task_id,
                    "REVIEW_HANDLED",
                    &format!("Addressed {} review comments", review_comments.len()),
                ).await?;
            }
        }

        Ok(())
    }

    // Ìñ•ÌõÑ CI Ïã§Ìå® ÏûêÎèô Ï≤òÎ¶¨ Í∏∞Îä•ÏóêÏÑú ÏÇ¨Ïö© ÏòàÏ†ï
    #[allow(dead_code)]
    pub async fn handle_ci_failure(
        &self,
        task_id: &str,
        pr_number: u32,
        ci_logs: &str,
    ) -> Result<()> {
        tracing::info!("Handling CI failure for task: {}", task_id);

        let (owner, name) = self.get_repository_info(task_id).await?;
        let repository = Repository::new(owner, name);

        // Use AI to fix CI failures
        let result = self.ai_agent.fix_ci_failures(ci_logs).await?;

        if result.success {
            tracing::info!("Fixed CI failures for PR #{}", pr_number);

            // Comment on PR
            let comment = format!(
                "üîß Fixed CI failures automatically:\n\n**Fixes applied:**\n{}",
                result.changes_made.iter()
                    .map(|c| format!("- {}", c))
                    .collect::<Vec<_>>()
                    .join("\n")
            );

            self.github_client
                .create_pr_comment(&repository, pr_number, &comment)
                .await?;

            // Log to database
            if let Some(ref db) = self.db {
                db.add_execution_log(
                    task_id,
                    "CI_FIXED",
                    &format!("Fixed {} CI issues", result.changes_made.len()),
                ).await?;
            }
        }

        Ok(())
    }
}